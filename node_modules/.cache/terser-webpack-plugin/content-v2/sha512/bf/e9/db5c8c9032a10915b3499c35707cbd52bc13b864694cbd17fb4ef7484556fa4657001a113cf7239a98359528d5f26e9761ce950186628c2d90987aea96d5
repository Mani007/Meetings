{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\",\"/home/akshayk/jitsi/Meetings/react/features/local-recording/recording/flac/flacEncodeWorker.js\",\"/home/akshayk/jitsi/Meetings/react/features/local-recording/recording/flac/messageTypes.js\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"self\",\"FLAC_SCRIPT_LOCATION\",\"importScripts\",\"FLAC_ERRORS\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"EncoderState\",\"freeze\",\"UNINTIALIZED\",\"WORKING\",\"FINISHED\",\"FLAC_COMPRESSION_LEVEL\",\"Encoder\",\"constructor\",\"sampleRate\",\"bitDepth\",\"bufferSize\",\"_defineProperty\",\"this\",\"Flac\",\"isReady\",\"Error\",\"_sampleRate\",\"_bitDepth\",\"_bufferSize\",\"_encoderId\",\"init_libflac_encoder\",\"init_encoder_stream\",\"_onEncodedData\",\"_onMetadataAvailable\",\"_state\",\"encode\",\"audioData\",\"bufferLength\",\"length\",\"bufferI32\",\"Int32Array\",\"view\",\"DataView\",\"buffer\",\"index\",\"setInt32\",\"FLAC__stream_encoder_process_interleaved\",\"errorNo\",\"FLAC__stream_encoder_get_state\",\"console\",\"error\",\"finish\",\"status\",\"FLAC__stream_encoder_finish\",\"log\",\"FLAC__stream_encoder_delete\",\"_data\",\"_exportFlacBlob\",\"getBlob\",\"samples\",\"arrays\",\"totalLength\",\"result\",\"Uint8Array\",\"offset\",\"len\",\"set\",\"mergeUint8Arrays\",\"_flacBuffers\",\"_flacLength\",\"Blob\",\"type\",\"bytes\",\"push\",\"byteLength\",\"encoder\",\"onmessage\",\"e\",\"data\",\"command\",\"bps\",\"config\",\"postMessage\",\"onready\",\"setTimeout\",\"buf\"],\"mappings\":\"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\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"/libs/\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 0);\\n\",\"\\nimport {\\n    MAIN_THREAD_FINISH,\\n    MAIN_THREAD_INIT,\\n    MAIN_THREAD_NEW_DATA_ARRIVED,\\n    WORKER_BLOB_READY,\\n    WORKER_LIBFLAC_READY\\n} from './messageTypes';\\n\\n/**\\n * WebWorker that does FLAC encoding using libflac.js\\n */\\n\\nself.FLAC_SCRIPT_LOCATION = '/libs/';\\n/* eslint-disable */\\nimportScripts('/libs/libflac4-1.3.2.min.js');\\n/* eslint-enable */\\n\\n// There is a number of API calls to libflac.js, which does not conform\\n// to the camalCase naming convention, but we cannot change it.\\n// So we disable the ESLint rule `new-cap` in this file.\\n/* eslint-disable new-cap */\\n\\n// Flow will complain about the number keys in `FLAC_ERRORS`,\\n// ESLint will complain about the `declare` statement.\\n// As the current workaround, add an exception for eslint.\\n/* eslint-disable flowtype/no-types-missing-file-annotation */\\ndeclare var Flac: Object;\\n\\nconst FLAC_ERRORS = {\\n    // The encoder is in the normal OK state and samples can be processed.\\n    0: 'FLAC__STREAM_ENCODER_OK',\\n\\n    // The encoder is in the uninitialized state one of the\\n    // FLAC__stream_encoder_init_*() functions must be called before samples can\\n    // be processed.\\n    1: 'FLAC__STREAM_ENCODER_UNINITIALIZED',\\n\\n    // An error occurred in the underlying Ogg layer.\\n    2: 'FLAC__STREAM_ENCODER_OGG_ERROR',\\n\\n    // An error occurred in the underlying verify stream decoder; check\\n    // FLAC__stream_encoder_get_verify_decoder_state().\\n    3: 'FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR',\\n\\n    // The verify decoder detected a mismatch between the original audio signal\\n    // and the decoded audio signal.\\n    4: 'FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA',\\n\\n    // One of the callbacks returned a fatal error.\\n    5: 'FLAC__STREAM_ENCODER_CLIENT_ERROR',\\n\\n    // An I/O error occurred while opening/reading/writing a file. Check errno.\\n    6: 'FLAC__STREAM_ENCODER_IO_ERROR',\\n\\n    // An error occurred while writing the stream; usually, the write_callback\\n    // returned an error.\\n    7: 'FLAC__STREAM_ENCODER_FRAMING_ERROR',\\n\\n    // Memory allocation failed.\\n    8: 'FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR'\\n};\\n\\n/**\\n * States of the {@code Encoder}.\\n */\\nconst EncoderState = Object.freeze({\\n    /**\\n     * Initial state, when libflac.js is not initialized.\\n     */\\n    UNINTIALIZED: 'uninitialized',\\n\\n    /**\\n     * Actively encoding new audio bits.\\n     */\\n    WORKING: 'working',\\n\\n    /**\\n     * Encoding has finished and encoded bits are available.\\n     */\\n    FINISHED: 'finished'\\n});\\n\\n/**\\n * Default FLAC compression level.\\n */\\nconst FLAC_COMPRESSION_LEVEL = 5;\\n\\n/**\\n * Concat multiple Uint8Arrays into one.\\n *\\n * @param {Uint8Array[]} arrays - Array of Uint8 arrays.\\n * @param {number} totalLength - Total length of all Uint8Arrays.\\n * @returns {Uint8Array}\\n */\\nfunction mergeUint8Arrays(arrays, totalLength) {\\n    const result = new Uint8Array(totalLength);\\n    let offset = 0;\\n    const len = arrays.length;\\n\\n    for (let i = 0; i < len; i++) {\\n        const buffer = arrays[i];\\n\\n        result.set(buffer, offset);\\n        offset += buffer.length;\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * Wrapper class around libflac API.\\n */\\nclass Encoder {\\n\\n    /**\\n     * Flac encoder instance ID. (As per libflac.js API).\\n     * @private\\n     */\\n    _encoderId = 0;\\n\\n    /**\\n     * Sample rate.\\n     * @private\\n     */\\n    _sampleRate;\\n\\n    /**\\n     * Bit depth (bits per sample).\\n     * @private\\n     */\\n    _bitDepth;\\n\\n    /**\\n     * Buffer size.\\n     * @private\\n     */\\n    _bufferSize;\\n\\n    /**\\n     * Buffers to store encoded bits temporarily.\\n     */\\n    _flacBuffers = [];\\n\\n    /**\\n     * Length of encoded FLAC bits.\\n     */\\n    _flacLength = 0;\\n\\n    /**\\n     * The current state of the {@code Encoder}.\\n     */\\n    _state = EncoderState.UNINTIALIZED;\\n\\n    /**\\n     * The ready-for-grab downloadable Blob.\\n     */\\n    _data = null;\\n\\n\\n    /**\\n     * Constructor.\\n     * Note: Only create instance when Flac.isReady() returns true.\\n     *\\n     * @param {number} sampleRate - Sample rate of the raw audio data.\\n     * @param {number} bitDepth - Bit depth (bit per sample).\\n     * @param {number} bufferSize - The size of each batch.\\n     */\\n    constructor(sampleRate, bitDepth = 16, bufferSize = 4096) {\\n        if (!Flac.isReady()) {\\n            throw new Error('libflac is not ready yet!');\\n        }\\n\\n        this._sampleRate = sampleRate;\\n        this._bitDepth = bitDepth;\\n        this._bufferSize = bufferSize;\\n\\n        // create the encoder\\n        this._encoderId = Flac.init_libflac_encoder(\\n            this._sampleRate,\\n\\n            // Mono channel\\n            1,\\n            this._bitDepth,\\n\\n            FLAC_COMPRESSION_LEVEL,\\n\\n            // Pass 0 in becuase of unknown total samples,\\n            0,\\n\\n            // checksum, FIXME: double-check whether this is necessary\\n            true,\\n\\n            // Auto-determine block size (samples per frame)\\n            0\\n        );\\n\\n        if (this._encoderId === 0) {\\n            throw new Error('Failed to create libflac encoder.');\\n        }\\n\\n        // initialize the encoder\\n        const initResult = Flac.init_encoder_stream(\\n            this._encoderId,\\n            this._onEncodedData.bind(this),\\n            this._onMetadataAvailable.bind(this)\\n        );\\n\\n        if (initResult !== 0) {\\n            throw new Error('Failed to initalise libflac encoder.');\\n        }\\n\\n        this._state = EncoderState.WORKING;\\n    }\\n\\n    /**\\n     * Receive and encode new data.\\n     *\\n     * @param {Float32Array} audioData - Raw audio data.\\n     * @returns {void}\\n     */\\n    encode(audioData) {\\n        if (this._state !== EncoderState.WORKING) {\\n            throw new Error('Encoder is not ready or has finished.');\\n        }\\n\\n        if (!Flac.isReady()) {\\n            throw new Error('Flac not ready');\\n        }\\n        const bufferLength = audioData.length;\\n\\n        // Convert sample to signed 32-bit integers.\\n        // According to libflac documentation:\\n        // each sample in the buffers should be a signed integer,\\n        // right-justified to the resolution set by\\n        // FLAC__stream_encoder_set_bits_per_sample().\\n\\n        // Here we are using 16 bits per sample, the samples should all be in\\n        // the range [-32768,32767]. This is achieved by multipling Float32\\n        // numbers with 0x7FFF.\\n\\n        const bufferI32 = new Int32Array(bufferLength);\\n        const view = new DataView(bufferI32.buffer);\\n        const volume = 1;\\n        let index = 0;\\n\\n        for (let i = 0; i < bufferLength; i++) {\\n            view.setInt32(index, audioData[i] * (0x7FFF * volume), true);\\n            index += 4; // 4 bytes (32-bit)\\n        }\\n\\n        // pass it to libflac\\n        const status = Flac.FLAC__stream_encoder_process_interleaved(\\n            this._encoderId,\\n            bufferI32,\\n            bufferI32.length\\n        );\\n\\n        if (status !== 1) {\\n            // gets error number\\n\\n            const errorNo\\n                = Flac.FLAC__stream_encoder_get_state(this._encoderId);\\n\\n            console.error('Error during encoding', FLAC_ERRORS[errorNo]);\\n        }\\n    }\\n\\n    /**\\n     * Signals the termination of encoding.\\n     *\\n     * @returns {void}\\n     */\\n    finish() {\\n        if (this._state === EncoderState.WORKING) {\\n            this._state = EncoderState.FINISHED;\\n\\n            const status = Flac.FLAC__stream_encoder_finish(this._encoderId);\\n\\n            console.log('Flac encoding finished: ', status);\\n\\n            // free up resources\\n            Flac.FLAC__stream_encoder_delete(this._encoderId);\\n\\n            this._data = this._exportFlacBlob();\\n        }\\n    }\\n\\n    /**\\n     * Gets the encoded flac file.\\n     *\\n     * @returns {Blob} - The encoded flac file.\\n     */\\n    getBlob() {\\n        if (this._state === EncoderState.FINISHED) {\\n            return this._data;\\n        }\\n\\n        return null;\\n    }\\n\\n    /**\\n     * Converts flac buffer to a Blob.\\n     *\\n     * @private\\n     * @returns {void}\\n     */\\n    _exportFlacBlob() {\\n        const samples = mergeUint8Arrays(this._flacBuffers, this._flacLength);\\n\\n        const blob = new Blob([ samples ], { type: 'audio/flac' });\\n\\n        return blob;\\n    }\\n\\n    /* eslint-disable no-unused-vars */\\n    /**\\n     * Callback function for saving encoded Flac data.\\n     * This is invoked by libflac.\\n     *\\n     * @private\\n     * @param {Uint8Array} buffer - The encoded Flac data.\\n     * @param {number} bytes - Number of bytes in the data.\\n     * @returns {void}\\n     */\\n    _onEncodedData(buffer, bytes) {\\n        this._flacBuffers.push(buffer);\\n        this._flacLength += buffer.byteLength;\\n    }\\n    /* eslint-enable no-unused-vars */\\n\\n    /**\\n     * Callback function for receiving metadata.\\n     *\\n     * @private\\n     * @returns {void}\\n     */\\n    _onMetadataAvailable = () => {\\n        // reserved for future use\\n    }\\n}\\n\\n\\nlet encoder = null;\\n\\nself.onmessage = function(e) {\\n\\n    switch (e.data.command) {\\n    case MAIN_THREAD_INIT:\\n    {\\n        const bps = e.data.config.bps;\\n        const sampleRate = e.data.config.sampleRate;\\n\\n        if (Flac.isReady()) {\\n            encoder = new Encoder(sampleRate, bps);\\n            self.postMessage({\\n                command: WORKER_LIBFLAC_READY\\n            });\\n        } else {\\n            Flac.onready = function() {\\n                setTimeout(() => {\\n                    encoder = new Encoder(sampleRate, bps);\\n                    self.postMessage({\\n                        command: WORKER_LIBFLAC_READY\\n                    });\\n                }, 0);\\n            };\\n        }\\n        break;\\n    }\\n\\n    case MAIN_THREAD_NEW_DATA_ARRIVED:\\n        if (encoder === null) {\\n            console.error('flacEncoderWorker received data when the encoder is not ready.');\\n        } else {\\n            encoder.encode(e.data.buf);\\n        }\\n        break;\\n\\n    case MAIN_THREAD_FINISH:\\n        if (encoder !== null) {\\n            encoder.finish();\\n            const data = encoder.getBlob();\\n\\n            self.postMessage(\\n                {\\n                    command: WORKER_BLOB_READY,\\n                    buf: data\\n                }\\n            );\\n            encoder = null;\\n        }\\n        break;\\n    }\\n};\\n\",\"/**\\n * Types of messages that are passed between the main thread and the WebWorker\\n * ({@code flacEncodeWorker})\\n */\\n\\n// Messages sent by the main thread\\n\\n/**\\n * Message type that signals the termination of encoding,\\n * after which no new audio bits should be sent to the\\n * WebWorker.\\n */\\nexport const MAIN_THREAD_FINISH = 'MAIN_THREAD_FINISH';\\n\\n/**\\n * Message type that carries initial parameters for\\n * the WebWorker.\\n */\\nexport const MAIN_THREAD_INIT = 'MAIN_THREAD_INIT';\\n\\n/**\\n * Message type that carries the newly received raw audio bits\\n * for the WebWorker to encode.\\n */\\nexport const MAIN_THREAD_NEW_DATA_ARRIVED = 'MAIN_THREAD_NEW_DATA_ARRIVED';\\n\\n// Messages sent by the WebWorker\\n\\n/**\\n * Message type that signals libflac is ready to receive audio bits.\\n */\\nexport const WORKER_LIBFLAC_READY = 'WORKER_LIBFLAC_READY';\\n\\n/**\\n * Message type that carries the encoded FLAC file as a Blob.\\n */\\nexport const WORKER_BLOB_READY = 'WORKER_BLOB_READY';\\n\\n// Messages sent by either the main thread or the WebWorker\\n\\n/**\\n * Debug messages.\\n */\\nexport const DEBUG = 'DEBUG';\\n\"]}","code":"!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"/libs/\",n(n.s=0)}([function(e,t,n){\"use strict\";n.r(t);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}self.FLAC_SCRIPT_LOCATION=\"/libs/\",importScripts(\"/libs/libflac4-1.3.2.min.js\");const i={0:\"FLAC__STREAM_ENCODER_OK\",1:\"FLAC__STREAM_ENCODER_UNINITIALIZED\",2:\"FLAC__STREAM_ENCODER_OGG_ERROR\",3:\"FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR\",4:\"FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA\",5:\"FLAC__STREAM_ENCODER_CLIENT_ERROR\",6:\"FLAC__STREAM_ENCODER_IO_ERROR\",7:\"FLAC__STREAM_ENCODER_FRAMING_ERROR\",8:\"FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR\"},o=Object.freeze({UNINTIALIZED:\"uninitialized\",WORKING:\"working\",FINISHED:\"finished\"}),a=5;class s{constructor(e,t=16,n=4096){if(r(this,\"_encoderId\",0),r(this,\"_flacBuffers\",[]),r(this,\"_flacLength\",0),r(this,\"_state\",o.UNINTIALIZED),r(this,\"_data\",null),r(this,\"_onMetadataAvailable\",()=>{}),!Flac.isReady())throw new Error(\"libflac is not ready yet!\");if(this._sampleRate=e,this._bitDepth=t,this._bufferSize=n,this._encoderId=Flac.init_libflac_encoder(this._sampleRate,1,this._bitDepth,a,0,!0,0),0===this._encoderId)throw new Error(\"Failed to create libflac encoder.\");if(0!==Flac.init_encoder_stream(this._encoderId,this._onEncodedData.bind(this),this._onMetadataAvailable.bind(this)))throw new Error(\"Failed to initalise libflac encoder.\");this._state=o.WORKING}encode(e){if(this._state!==o.WORKING)throw new Error(\"Encoder is not ready or has finished.\");if(!Flac.isReady())throw new Error(\"Flac not ready\");const t=e.length,n=new Int32Array(t),r=new DataView(n.buffer);let a=0;for(let n=0;n<t;n++)r.setInt32(a,32767*e[n],!0),a+=4;if(1!==Flac.FLAC__stream_encoder_process_interleaved(this._encoderId,n,n.length)){const e=Flac.FLAC__stream_encoder_get_state(this._encoderId);console.error(\"Error during encoding\",i[e])}}finish(){if(this._state===o.WORKING){this._state=o.FINISHED;const e=Flac.FLAC__stream_encoder_finish(this._encoderId);console.log(\"Flac encoding finished: \",e),Flac.FLAC__stream_encoder_delete(this._encoderId),this._data=this._exportFlacBlob()}}getBlob(){return this._state===o.FINISHED?this._data:null}_exportFlacBlob(){const e=function(e,t){const n=new Uint8Array(t);let r=0;const i=e.length;for(let t=0;t<i;t++){const i=e[t];n.set(i,r),r+=i.length}return n}(this._flacBuffers,this._flacLength);return new Blob([e],{type:\"audio/flac\"})}_onEncodedData(e,t){this._flacBuffers.push(e),this._flacLength+=e.byteLength}}let _=null;self.onmessage=function(e){switch(e.data.command){case\"MAIN_THREAD_INIT\":{const t=e.data.config.bps,n=e.data.config.sampleRate;Flac.isReady()?(_=new s(n,t),self.postMessage({command:\"WORKER_LIBFLAC_READY\"})):Flac.onready=function(){setTimeout(()=>{_=new s(n,t),self.postMessage({command:\"WORKER_LIBFLAC_READY\"})},0)};break}case\"MAIN_THREAD_NEW_DATA_ARRIVED\":null===_?console.error(\"flacEncoderWorker received data when the encoder is not ready.\"):_.encode(e.data.buf);break;case\"MAIN_THREAD_FINISH\":if(null!==_){_.finish();const e=_.getBlob();self.postMessage({command:\"WORKER_BLOB_READY\",buf:e}),_=null}}}}]);","extractedComments":[]}